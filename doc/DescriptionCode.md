# Описание работы кода

Основная логика кода разбита на две состовляющие: 
- Клиентаская часть - [dicomp.py](/scr/dicomp.py)
- Серверная часть - [server.py](/scr/server.py)

Так же в репозитории встречаються тестовые программы, на которых были протестированны некоторые функции:
- Файл [test.py](/scr/tests_script/test.py)
- Файл [testClient.py](/scr/tests_script/testClient.py)

Все они распологаются в папке [/scr/test_script](/scr/tests_script/)

## Клиентаская часть
### dicomp.py

В первых строках идет краткое описание выполняемых функций кода в этом файле.
Далее идут импорты всех библиотек, необходимых для нормальной работы кода. Здесь испортируются:


1. threading - работа с потоками. Встроенна в python.
2. inspect - работа с исходным кодом. Требует дополнительной установки
   > 
   > pip install inspect
   >
3. socket - работа с сетью и сетевыми данными. Встроенна в python.
4. sys - работа с интерпритатором python и дополняет некоторыми функциями. Встроенна в python.
5. io - работа с файлами и их свойствами. Встроенн в python.
6. os - работа с системными файлами. Встроенна в python.

<br>

Сразу после импортов есть несколько глобальных констант:
```python
COUNT_TASKS:int = 0
SOCKET_SPEED:int = 4096


NOT_SAVE:bool = True
SAVE_NAME:str = ""
```

Здесь переменная ```COUNT_TASKS``` считает количество небходимых вычислений и формирует по ним ответно-запросную систему передачи файлов.

В переменной ```SOCKET_SPEED``` храниться скорость обмена данными между клиентом и сервером. Скорость выражена целом числом, характеризующие количество информации в одном пакете данных. Эксперементальным путем было подобранно число 4096.

Переменная ```NOT_SAVE``` булевого типа, т.е принимает значения Правда/Ложь. Она говорит нам о том, какое действие нам требуеться соверишить - Вернуть ответ или записать ответ в качестве сохранения.

Соответсвенно в переменной ```SAVE_NAME``` храниться имя сохраняемого объекта.

<br>

Далее идет описание самой логики класса Dicomp.
При инициализации создаются несколько переменных, требующиеся в дальнейшем. Так например, в переменной ```self.name_folder_cache```  храниться имя папки в которую будут записанны сохранения. Данную папку можно переименовать по усмотрению. 

```python
def __init__(self):
        self.IP:str = ""
        self.PORT:int = 0
        
        self.name_folder_cache = "dicomp_cache"
```

Переменные IP и PORT назначаются в коде, позже.

<br>

Основная логика распределенных вычисление строиться на декорировании тех функций, которые необходимо распределить. 

Метод называеться ```calculate```. В качестве параметров принимает два обязательных и два необязательных. Обязательно нужно передать ip адрес и порт по которому будет установленно соединение с сервером. IP адрес представляеться в виде стоки, а порт в виде целого числа. Эти данные можно узнать после запуска скрипта [серверной части](/doc/DescriptionCode.md#серверная-часть).

Необязательные параметры - это ```isReturn``` булевого типа. Он служит для того, чтобы определить присутсвуетли в функцие/методе оператор *return*. И строить логику на этой основе. Параметр необязателен тольоков тех случаях, когда ваша функция что-то возвращает.

Так же есть необязательный параметр - ```useSave``` тоже булевого типа. Данный параметр нужен для того, чтобы определить - использовать сохраненные ранее файлы или нет. В некотрых случаях вам может потребоваться посмотреть отказоустойчивость вашего кода и тогда просто поменяйте данный параметр на *False*. 

Способ передачи данных между сервером и клиентом весьма примитивен. Береться декорируемая функция и, с помощью библиотеки inspect, извлекаеться исходный код программы. 

Данный код записывается в отдельный текстовы файл, который создаеться с именем соответсвующий номеру его подключения. С точки зрения программы, можно использовать любое название, однако стоит понимать, что как сервер, так и клиент работают в многопоточном режиме, что не позволяет сделать единую линию передачи информации.







## Серверная часть
### server.py

