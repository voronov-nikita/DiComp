# Описание работы кода

Основная логика кода разбита на две состовляющие: 
- Клиентаская часть - [dicomp.py](/scr/dicomp.py)
- Серверная часть - [server.py](/scr/server.py)

Так же в репозитории встречаються тестовые программы, на которых были протестированны некоторые функции:
- Файл [test.py](/scr/tests_script/test.py)
- Файл [testClient.py](/scr/tests_script/testClient.py)

Все они распологаются в папке [/scr/test_script](/scr/tests_script/)

## Клиентаская часть
### dicomp.py

В первых строках идет краткое описание выполняемых функций кода в этом файле.
Далее идут импорты всех библиотек, необходимых для нормальной работы кода. Здесь испортируются:


1. threading - работа с потоками. Встроенна в python.
2. inspect - работа с исходным кодом. Требует дополнительной установки
   > 
   > pip install inspect
   >
3. socket - работа с сетью и сетевыми данными. Встроенна в python.
4. sys - работа с интерпритатором python и дополняет некоторыми функциями. Встроенна в python.
5. io - работа с файлами и их свойствами. Встроенн в python.
6. os - работа с системными файлами. Встроенна в python.

<br>

Сразу после импортов есть несколько глобальных констант:
```python
COUNT_TASKS:int = 0
SOCKET_SPEED:int = 4096


NOT_SAVE:bool = True
SAVE_NAME:str = ""
```

Здесь переменная ```COUNT_TASKS``` считает количество небходимых вычислений и формирует по ним ответно-запросную систему передачи файлов.

В переменной ```SOCKET_SPEED``` храниться скорость обмена данными между клиентом и сервером. Скорость выражена целом числом, характеризующие количество информации в одном пакете данных. Эксперементальным путем было подобранно число 4096.

Переменная ```NOT_SAVE``` булевого типа, т.е принимает значения Правда/Ложь. Она говорит нам о том, какое действие нам требуеться соверишить - Вернуть ответ или записать ответ в качестве сохранения.

Соответсвенно в переменной ```SAVE_NAME``` храниться имя сохраняемого объекта.

<br>

Далее идет описание самой логики класса Dicomp.
При инициализации создаются несколько переменных, требующиеся в дальнейшем. Так например, в переменной ```self.name_folder_cache```  храниться имя папки в которую будут записанны сохранения. Данную папку можно переименовать по усмотрению. 

```python
def __init__(self):
        self.IP:str = ""
        self.PORT:int = 0
        
        self.name_folder_cache = "dicomp_cache"
```

Переменные IP и PORT назначаются в коде, позже.

<br>

Основная логика распределенных вычисление строиться на декорировании тех функций, которые необходимо распределить. 

Метод называеться ```calculate```. В качестве параметров принимает два обязательных и два необязательных. Обязательно нужно передать ip адрес и порт по которому будет установленно соединение с сервером. IP адрес представляеться в виде стоки, а порт в виде целого числа. Эти данные можно узнать после запуска скрипта [серверной части](/doc/DescriptionCode.md#серверная-часть).

Необязательные параметры - это ```isReturn``` булевого типа. Он служит для того, чтобы определить присутсвуетли в функцие/методе оператор *return*. И строить логику на этой основе. Параметр необязателен тольоков тех случаях, когда ваша функция что-то возвращает.

Так же есть необязательный параметр - ```useSave``` тоже булевого типа. Данный параметр нужен для того, чтобы определить - использовать сохраненные ранее файлы или нет. В некотрых случаях вам может потребоваться посмотреть отказоустойчивость вашего кода и тогда просто поменяйте данный параметр на *False*. 

Способ передачи данных между сервером и клиентом весьма примитивен. Береться декорируемая функция и, с помощью библиотеки inspect, извлекаеться исходный код программы. 

Данный код записывается в отдельный текстовы файл, который создаеться с именем соответсвующий номеру его подключения. С точки зрения программы, можно использовать любое название, однако стоит понимать, что как сервер, так и клиент работают в многопоточном режиме, что не позволяет сделать единую линию передачи информации.

После того, как сервер обработает запрос, клиент получит ответ. В зависимости от параметров, выставленных в качестве параметров декоратора, будет выдан ответ.




## Серверная часть
### server.py

Серверная часть описана в файле [server.py](/scr/server.py) и представляет собой лишь пример использования технологии серверно-клиентских сокетов.

Для корректной работы всей системы, помимо клиентской части требуется иметь сервер, на котором как раз будут проходить основные вычисления. Реализации серверной части могут быть разными, но во всех них должны присутсвовать основные концепции, без которых работать не получиться. О подобных концепциях и пойдет речь ниже.

Для начала, стот понимать, что клиенсткая часть работает по принципу сокетов, поэтому нам потребуется встроенная библиотека `socket`, которую мы использовали в клиенской части. Импортируем ее и еще несколько библиотек, к примеру библиотека `threading`, для работы с потоками. Наш сервер должен уметь принимать несколько одновременных подключений. В качестве аналога можно использовать `multiprocessing`.

В примере еще используется библиотека `subprocess` для работы с терминалом и его выходами. Безусловно, можно было использовать `sys` для перехвата вывода в консоль, но в таком случае, нам потребовалось бы выполнить больше действий для вызова действия нашего python скрипта.

Перед началом работы стоит определить несколько констант:

```python

IP:str = socket.gethostbyname(socket.gethostname())
PORT:int = 12345


SOCKET_SPEED:int = 4096
COUNT_CONNECT:int = 0
# if you use PYPY, then True
USING_PYPY:bool = True

```

Здесь в переменную IP и PORT записываются данные из сети сервера. Используются для дальнейшего обмена информацией между серверами и клиентом.

SOCKET_SPEED - это переменная, отвечающая за скорость обмена данными в сети. Данный параметр должен быть не меньше того, что указан на стороне клиента. Это принципиально важно, так как от этого будет зависеть полнота передаваемого пакета данных.

Переменная COUNT_CONNECT служит в роли распределения файлов по задачам, подобно тому, как это сделано в клиентской части.


Далее важно знать, что клиент отправляет файлы, а значит сервер в первую очередь должен принимать файлы, а не информацию.

функция, преобразующая поток байтов в исходный файл выглядит подобным образом:

```python
# make a record with the received data
def write_task(self, number:int, data:bytes) -> None:
        with open(f"new{number}.txt", 'wb') as file:
            file.write(data)
```

Она ничего не возвращает, зато образует новый текстовый файл с переданной информацией.

Еще важно помнить, что сервер работает постоянно и без остановки, из-за чего могут возникнуть проблемы с многопоточностью. Чтобы этого не допустить, было принято решение использовать отдельный класс под названием `NewConnect`, наследуемый от класса `Thread` модуля threading.