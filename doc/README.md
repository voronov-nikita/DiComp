# Documentation

С файлом-описанием действий самого кода можно ознакомиться [здесь](/doc/DescriptionCode.md)

----------------


**Dicomp** - это самописная библиотека Python, которая служит для некоторого ускорения кода на python путем распределения базовых вычислений по одному или нескольким серверам или процессорам.

>from dicomp import Dicomp


Чтобы подключиться к серверу, используйте функцию-декоратор из модуля Dicomp -> *@calculate*

1. Пример со стороны пользователя:
    ```python
    from dicomp import Dicomp

    # initializing the Dicomp object
    server = Dicomp()

    # this decorator takes in the values of the IP address and port to connect to the server on which the calculations will be performed.
    @server.calculate(ip="0.0.0.0", port=0)
    def function_example(a, b):
        # your code
        return a + b

    # Be sure to call the function
    function_example(10, 50)
    ```

    Здесь происходит несколько вещей:
    - импорт библиотеки dicomp
    - определение объекта класса Dicomp
    - формирование задачи и присоединение к серверу
    - выполнение функции
    
    <br>

2. Пример вывода с сервера:

    ```Bash
    SERVER IS RUN... 
    IP: 0.0.0.0
    PORT: 0

    192.168.0.0 523462
    OUT: b'60'

    ```

    - Здесь, показано то, что после запуска сервера выведеться основная информация о нем(IP адрес и порт для подключения). 
    
    - К серверу подключился пользователь с IP-адресом 192.168.0.0 по порту 523462
    - Сервер выполнил некое вычисление, результатом которой являеться битовая строка. Эти данные отправляються обратно пользователю.


### Сохраненние промежуточных результатов

Была предусмотренна возможность сохранять уже полученные результаты ваших функций. Это позволяет экономить ресурсы как серверной части, так и клиентской.

Для использования возможности сохранения требуеться импортировать еще одинин класс - *SaveData*.

Чтобы сохранить результат необходимо этот результат получить. Поэтому прежде всего потребуеться вызвать все те функции, результат которых хотим сохранить. Перед тем, как вызвать все функции пропишем метод из класса SaveData - *start_save()*, а после окончания обязательно пропишем метод *end_save()* из того же класса.



```python
from dicomp import Dicomp, SaveData

server = Dicomp()
saves = SavaData()

@server.calculate(ip="0.0.0.0", port=0)
def function_example(a, b):
    return a + b

# begin save
saves.start_save()

function_example(10, 50)

# end save
saves.stop_save()
```

Теперь после того, как от сервера нам придет ответ все, что находиться внутри конструкции `start_save - end_save` сохраниться с указанными параметрами.

Важно понимать, что сохранение происходит исключительно с теми параметрами, которые были переданны при выполнении функции. При изменении данных параметров придется также менять их сохранение.

##### От использования сохраненных записей можно отказаться
Для этого необходимо просто в качестве аргумента `useSave` в методе `calculate` класса указать *False*:

```python
    from dicomp import Dicomp

    server = Dicomp()
    @server.calculate(ip="0.0.0.0", port=0, useSave=False)
    def function_example(a, b):
        # your code
        return a + b

    
    function_example(10, 50)
```

В этом случае результат не будет выбран из сохраненных, даже если он там есть.

<br><br>


###### 20.10.2023 - last README.md change.