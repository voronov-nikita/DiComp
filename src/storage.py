#
# Файл , содержащий в себе код для запуска распределенного хранилища.
# Распрдееленное хранилище - это способ организации данных,
# при котором один файл разделяется на несколько маленьких (возможно даже и не полных) и рассылается на несколько серверов (хранилищ)
# Такая схема организации данных позволяет сохранить безопастность и целостность данных.
#


from threading import Thread
import sqlite3 as sql
import configparser
import socket

# from net import *


# Описание конфигурации текущего файла
config = configparser.ConfigParser()
config.read('config.ini')

# Получение значений из файла конфигурации
FILE: str = config['Storage']['database_file']
HOST: str = config['Storage']['host']
PORT: int = int(config['Storage']['port'])


class Storage():
    def __init__(self) -> None:
        '''
        Класс конфигурации и основных принципов для организации распределенного хранилища,
        где хранятся принципы:

        1. Организация контроля данных
        2. Организация отправки и принятия файлов
        3. Организация проверки целостности данных на всех серверах
        4. организация запуска проекта

        Все описанные методы и функции являются описанием схожих 
        конфигураций для отдельных вызовов при других параметрах.

        '''

        self.sock: object | None = None

        self._initSystem()

    def _initSystem(self):
        '''
        Функция инициализации работы основных принципов и состояний подключения 
        для развертывания распределенного хранилища.


        Происходит загрузка:

        - базы данных, содержащая в себе
        '''

        self._initDataBase()
        self._initSocket()

    def _initSocket(self) -> None:
        '''
        Функция инициализации подключения по TCP/IP технологии.

        Инициализация сокетов необходима для проверки сохранности и полноты действий в коде.
        После инициализации открывается новый тип сокетного подлючения типа `Socket`.

        Функция ничего не возвращает, но создает в текущем объекте новый объект сокета.

        Данные о хосте и порте подключения берутся из файла конфигурации текущей директории.
        '''

        self.sock = socket.socket(socket.AF_INET)
        self.sock.bind((HOST, PORT))

    def _initDataBase(self):
        '''
        Функция инициализации базы данных со списком текущих сеансов серверов 
        и хранением их текущих текущих сессий в распределенном хранилище

        Создается локальный файл базы данных, содержащий в себе следующую информацию:

        - id - уникальный индетификатор, автоинкрементируемый (самоставищайся). 
        Необходим для указания порядка и стабильности хранения данных.

        - user - уникальный логин пользователя в системе платформы DiComp.
        Логин необходим для подтверждения сохранения конфедециальности пользователя и его данных.

        - server - список индетификаторов серверов, на которых храниться информация об этой сессии.
        Под сессией в этом случае подразумевается все сервера, хранящие на себе информацию о конкретном файле.

        База данных должна поддерживать принцип "долговечной памяти".
        '''

        db = sql.connect(FILE)
        cursor = db.cursor()

        # номера серверов разделены из массива данных будут разделены
        # по принципу csv фалов (с разделителем "";"")
        cursor.execute("""
        CREATE TABLE IF NOT EXISTS files (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user TEXT NOT NULL,
            name TEXT,
            servers TEXT NOT NULL
        )
        """)

        db.commit()
        db.close()

    def _addDatabase(self, user: str, servers: list, fileName: str = "") -> bool | tuple:
        '''
        Функция добавления новых данных в базу данных с серверами и текущими сессиями.

        Функция принмает в себя дав обязаьельных аргумента:

        - user - уникальный логин пользователя, которому принадлежат данные
        - servers - массив со списком серверов, на которые будут распределены данные пользователя.

        В случае успешного добавления данных функция вернет булевое значение True, 
        в простивном случае вернется False с именем ошибки.
        '''

        db = sql.connect(FILE)
        cursor = db.cursor()

        # номера серверов разделены из массива данных будут разделены
        # по принципу csv фалов (с разделителем "";"")
        try:
            serv = ';'.join(servers)

            cursor.execute(f"""
            INSERT INTO files(user, servers, name) VALUES('{user}', '{serv}', '{fileName}')
            """)

            db.commit()
            db.close()

            # если ошибок не возниуло, вернуть True
            return True,
        except Exception as error:
            return False, error

    def getFile(self, file: str) -> None:
        '''

        '''

        pass

    def sendFile(seklf, file: str, timeName: str = "time0.txt") -> bool:
        '''
        Функция отправки собранного файла обратно клиенту.

        Функция создает временный файл с новым именем потока или именем по умолчанию.

        Возвращает булевое выражение True в случае удачного и успешной доставки файла до клиента.
        В обратном случае вернется False с именем ошибки.
        '''

        try:
            return True

        except Exception as error:
            return False, error

    def checkFile(self, fileId: int) -> bool:
        '''

        '''

        return False

    def start(self, mode: int = 1) -> None | TypeError:
        '''
        Запуск распределенного хранилища с особым режимом работы (по умолчанию режим работы: №1, т.е работа в качестве принимающего и хранящего устройства)
        В случае выбора режима работы №2 устройство начинает работать в качестве распределяющего устройсвта.
        По сути такого распределяющего устройсва достаточно всего одного, 
        но при необходимости и требовании в масштабировании можно обьеденить все устройства через технологию "Распределенная сеть".

        Принимает в себя 1 необязательный аргумент - режим работы:
        - `mode` - целое число (1 или 2), где режим работы №1 - работа в качестве хранилища, №2 - работа в качестве головного отдела.


        '''

        if mode == 1:
            print(1)
        elif mode == 2:
            print(2)
        else:
            raise TypeError(
                "The operating mode is specified incorrectly, only 1 or 2 are allowed")


if __name__ == "__main__":
    st = Storage()
    st.start(mode=2)
